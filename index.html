<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Swing Scanner Pro</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet"/>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#040608;overflow:hidden}
    ::-webkit-scrollbar{width:3px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:#111820;border-radius:3px}
    input::placeholder{color:#1e3050}select option{background:#080b0e}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:0.3}}
    @keyframes pulse{0%,100%{opacity:0.4}50%{opacity:1}}
    @keyframes fadeIn{from{opacity:0;transform:translateX(10px)}to{opacity:1;transform:translateX(0)}}
  </style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
<script type="text/babel">
const {useState,useEffect,useCallback,useRef,useMemo}=React;
const BASE="https://api.binance.com/api/v3";

// â”€â”€â”€ SIGNAL COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SC={
  "PRIME":  {bg:"#04160b",border:"#00ff88",text:"#00ff88",glow:"#00ff8840"},
  "STRONG": {bg:"#061612",border:"#22c55e",text:"#22c55e",glow:"#22c55e30"},
  "WATCH":  {bg:"#141000",border:"#eab308",text:"#eab308",glow:"#eab30820"},
  "AVOID":  {bg:"#140404",border:"#ef4444",text:"#ef4444",glow:"#ef444420"},
};

// â”€â”€â”€ TECHNICAL INDICATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcEMA(prices, period) {
  if (!prices || prices.length < period) return null;
  const k = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) ema = prices[i] * k + ema * (1 - k);
  return ema;
}

function calcEMASeries(prices, period) {
  if (!prices || prices.length < period) return [];
  const k = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  const series = new Array(period - 1).fill(null);
  series.push(ema);
  for (let i = period; i < prices.length; i++) { ema = prices[i] * k + ema * (1 - k); series.push(ema); }
  return series;
}

function calcRSI(prices, period = 14) {
  if (!prices || prices.length < period + 1) return 50;
  let gains = 0, losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const d = prices[i] - prices[i - 1];
    if (d > 0) gains += d; else losses -= d;
  }
  let ag = gains / period, al = losses / period;
  // Smooth with remaining bars
  for (let i = prices.length - period + 1; i < prices.length; i++) {
    const d = prices[i] - prices[i - 1];
    ag = (ag * (period - 1) + Math.max(d, 0)) / period;
    al = (al * (period - 1) + Math.max(-d, 0)) / period;
  }
  return al === 0 ? 100 : 100 - 100 / (1 + ag / al);
}

function calcMACD(prices) {
  if (!prices || prices.length < 26) return { macd: 0, signal: 0, hist: 0, crossover: false };
  const ema12 = calcEMASeries(prices, 12);
  const ema26 = calcEMASeries(prices, 26);
  const macdLine = ema12.map((v, i) => (v && ema26[i]) ? v - ema26[i] : null).filter(Boolean);
  if (macdLine.length < 9) return { macd: 0, signal: 0, hist: 0, crossover: false };
  const signalLine = calcEMASeries(macdLine, 9);
  const last = macdLine.length - 1;
  const macd = macdLine[last];
  const sig = signalLine[last];
  const prevMacd = macdLine[last - 1];
  const prevSig = signalLine[last - 1];
  const hist = macd - sig;
  // Bullish crossover: MACD just crossed above signal
  const crossover = prevMacd < prevSig && macd > sig;
  // Recent bullish cross (within last 3 bars)
  const recentCross = macdLine.slice(-3).some((m, i) => {
    const s = signalLine.slice(-3)[i];
    const pm = macdLine.slice(-4)[i];
    const ps = signalLine.slice(-4)[i];
    return pm && ps && pm < ps && m > s;
  });
  return { macd, signal: sig, hist, crossover, recentCross, bullish: macd > sig };
}

function calcBollingerBands(prices, period = 20, stdDev = 2) {
  if (!prices || prices.length < period) return { upper: 0, mid: 0, lower: 0, pct: 0.5 };
  const slice = prices.slice(-period);
  const mid = slice.reduce((a, b) => a + b, 0) / period;
  const variance = slice.reduce((a, b) => a + Math.pow(b - mid, 2), 0) / period;
  const std = Math.sqrt(variance);
  const upper = mid + stdDev * std;
  const lower = mid - stdDev * std;
  const price = prices[prices.length - 1];
  const pct = std === 0 ? 0.5 : (price - lower) / (upper - lower); // 0=at lower, 1=at upper
  return { upper, mid, lower, pct };
}

function detectCandlePattern(klines) {
  // klines: array of {o, h, l, c} objects
  if (!klines || klines.length < 3) return { pattern: "None", bullish: false, strength: 0 };
  const last = klines[klines.length - 1];
  const prev = klines[klines.length - 2];
  const prev2 = klines[klines.length - 3];
  const { o, h, l, c } = last;
  const body = Math.abs(c - o);
  const totalRange = h - l || 0.0001;
  const upperWick = h - Math.max(o, c);
  const lowerWick = Math.min(o, c) - l;

  // Hammer / Bullish Pin Bar: small body, long lower wick, near bottom
  if (lowerWick > body * 2 && lowerWick > upperWick * 2 && c > o)
    return { pattern: "Hammer", bullish: true, strength: 3 };

  // Bullish Engulfing: current green candle engulfs previous red
  if (c > o && prev.c < prev.o && c > prev.o && o < prev.c)
    return { pattern: "Bullish Engulfing", bullish: true, strength: 3 };

  // Morning Star: 3-candle reversal
  if (prev2.c < prev2.o && Math.abs(prev.c - prev.o) < totalRange * 0.3 && c > o && c > (prev2.o + prev2.c) / 2)
    return { pattern: "Morning Star", bullish: true, strength: 3 };

  // Bullish Harami: small green inside previous big red
  if (c > o && prev.c < prev.o && c < prev.o && o > prev.c && body < Math.abs(prev.c - prev.o) * 0.6)
    return { pattern: "Bullish Harami", bullish: true, strength: 2 };

  // Doji near support (indecision, potential reversal)
  if (body < totalRange * 0.1 && lowerWick > totalRange * 0.3)
    return { pattern: "Doji (Reversal?)", bullish: true, strength: 1 };

  // Inverted Hammer at bottom
  if (upperWick > body * 2 && lowerWick < body * 0.5 && c > o)
    return { pattern: "Inv. Hammer", bullish: true, strength: 1 };

  // Bearish patterns
  if (upperWick > body * 2 && c < o) return { pattern: "Shooting Star", bullish: false, strength: -2 };
  if (c < o && prev.c > prev.o && c < prev.o && o > prev.c) return { pattern: "Bearish Engulfing", bullish: false, strength: -3 };

  // Plain bullish or bearish candle
  if (c > o && body > totalRange * 0.6) return { pattern: "Strong Bullish", bullish: true, strength: 2 };
  if (c < o && body > totalRange * 0.6) return { pattern: "Strong Bearish", bullish: false, strength: -1 };

  return { pattern: "Neutral", bullish: false, strength: 0 };
}

function detectRSIDivergence(closes, period = 14) {
  if (closes.length < 30) return { bullishDiv: false, bearishDiv: false };
  // Check last 15 bars for divergence
  const rsiSeries = [];
  for (let i = period + 1; i <= closes.length; i++) rsiSeries.push(calcRSI(closes.slice(0, i)));
  const priceLast = closes[closes.length - 1];
  const pricePrev = Math.min(...closes.slice(-15, -5));
  const rsiLast = rsiSeries[rsiSeries.length - 1];
  const rsiPrev = Math.min(...rsiSeries.slice(-15, -5));
  // Bullish divergence: price made lower low but RSI made higher low
  const bullishDiv = priceLast < pricePrev && rsiLast > rsiPrev + 2;
  // Bearish divergence: price higher high but RSI lower high
  const priceHigh = closes[closes.length - 1] > Math.max(...closes.slice(-15, -5));
  const rsiHigh = rsiLast < Math.max(...rsiSeries.slice(-15, -5)) - 2;
  const bearishDiv = priceHigh && rsiHigh;
  return { bullishDiv, bearishDiv };
}

// â”€â”€â”€ SMC: PIVOT POINTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Finds swing highs/lows (left/right neighbours lower/higher)
function findPivots(highs, lows, lookback = 3) {
  const pivotHighs = [], pivotLows = [];
  for (let i = lookback; i < highs.length - lookback; i++) {
    const isHigh = highs.slice(i - lookback, i).every(h => h <= highs[i]) &&
                   highs.slice(i + 1, i + lookback + 1).every(h => h <= highs[i]);
    if (isHigh) pivotHighs.push({ idx: i, price: highs[i] });
    const isLow = lows.slice(i - lookback, i).every(l => l >= lows[i]) &&
                  lows.slice(i + 1, i + lookback + 1).every(l => l >= lows[i]);
    if (isLow) pivotLows.push({ idx: i, price: lows[i] });
  }
  return { pivotHighs, pivotLows };
}

// â”€â”€â”€ SMC: ORDER BLOCKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bullish OB = last bearish candle before a strong up-move
// Bearish OB = last bullish candle before a strong down-move
function detectOrderBlocks(opens, highs, lows, closes) {
  const n = closes.length;
  if (n < 10) return { bullishOB: null, bearishOB: null, atBullishOB: false, atBearishOB: false };
  const price = closes[n - 1];
  let bullishOB = null, bearishOB = null;

  // Look back last 40 bars for impulsive moves
  for (let i = n - 40; i < n - 3; i++) {
    if (i < 1) continue;
    const isBear = closes[i] < opens[i]; // bearish candle
    const bodySize = Math.abs(closes[i] - opens[i]);
    const range = highs[i] - lows[i] || 0.0001;

    // Bullish OB: bearish candle followed by 3+ consecutive bullish closes with strong displacement
    if (isBear) {
      const nextMove = closes[i + 3] - closes[i];
      const displacement = nextMove / closes[i];
      if (displacement > 0.02 && closes[i + 1] > closes[i] && closes[i + 2] > closes[i + 1]) {
        const obHigh = Math.max(opens[i], closes[i]);
        const obLow = Math.min(opens[i], closes[i]);
        // Price currently inside or just above OB = potential demand zone
        if (price >= obLow * 0.995 && price <= obHigh * 1.03) {
          bullishOB = { high: obHigh, low: obLow, idx: i, strength: displacement > 0.05 ? 3 : displacement > 0.03 ? 2 : 1 };
        }
      }
    }

    // Bearish OB: bullish candle followed by strong down-move
    if (!isBear) {
      const nextMove = closes[i + 3] - closes[i];
      const displacement = nextMove / closes[i];
      if (displacement < -0.02 && closes[i + 1] < closes[i] && closes[i + 2] < closes[i + 1]) {
        const obHigh = Math.max(opens[i], closes[i]);
        const obLow = Math.min(opens[i], closes[i]);
        if (price >= obLow * 0.97 && price <= obHigh * 1.005) {
          bearishOB = { high: obHigh, low: obLow, idx: i, strength: displacement < -0.05 ? 3 : 2 };
        }
      }
    }
  }

  return {
    bullishOB,
    bearishOB,
    atBullishOB: bullishOB !== null,
    atBearishOB: bearishOB !== null,
  };
}

// â”€â”€â”€ SMC: BREAK OF STRUCTURE (BOS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bullish BOS = price breaks above a prior swing high (structure break to upside)
// CHoCH = Change of Character = bearish â†’ bullish flip
function detectBOS(highs, lows, closes) {
  if (closes.length < 20) return { bullishBOS: false, bearishBOS: false, choch: false, bosLevel: null };
  const price = closes[closes.length - 1];
  const prevPrice = closes[closes.length - 2];
  const { pivotHighs, pivotLows } = findPivots(highs, lows, 3);

  // Last 2 pivot highs â€” bullish BOS = current price just broke above them
  const recentPivotHighs = pivotHighs.slice(-3).map(p => p.price);
  const recentPivotLows = pivotLows.slice(-3).map(p => p.price);

  let bullishBOS = false, bosLevel = null;
  for (const ph of recentPivotHighs) {
    // Price closed above a prior swing high this bar or last bar
    if (price > ph && prevPrice <= ph) {
      bullishBOS = true;
      bosLevel = ph;
      break;
    }
  }

  // Bearish BOS = price broke below a prior swing low
  let bearishBOS = false;
  for (const pl of recentPivotLows) {
    if (price < pl && prevPrice >= pl) { bearishBOS = true; break; }
  }

  // CHoCH: series of lower highs and lower lows followed by a break of the last lower high
  let choch = false;
  if (pivotHighs.length >= 3 && pivotLows.length >= 2) {
    const [ph1, ph2, ph3] = pivotHighs.slice(-3);
    const lowerHighSeries = ph2 && ph3 && ph3.price < ph2.price && ph2.price < ph1.price;
    if (lowerHighSeries && price > ph3.price) choch = true;
  }

  return { bullishBOS, bearishBOS, choch, bosLevel };
}

// â”€â”€â”€ SMC: DOUBLE BOTTOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Two pivot lows within 1.5% of each other, with a recovery peak between them
function detectDoubleBottom(highs, lows, closes) {
  if (closes.length < 20) return { doubleBottom: false, neckline: null, pattern: null };
  const price = closes[closes.length - 1];
  const { pivotLows, pivotHighs } = findPivots(highs, lows, 3);

  if (pivotLows.length < 2) return { doubleBottom: false, neckline: null, pattern: null };

  const last = pivotLows[pivotLows.length - 1];
  const prev = pivotLows[pivotLows.length - 2];

  // Both lows within 2% of each other (same level)
  const diff = Math.abs(last.price - prev.price) / Math.max(last.price, prev.price);
  if (diff > 0.02) return { doubleBottom: false, neckline: null, pattern: null };

  // Find the peak between the two lows
  const peakBetween = pivotHighs.find(ph => ph.idx > prev.idx && ph.idx < last.idx);
  if (!peakBetween) return { doubleBottom: false, neckline: null, pattern: null };
  const neckline = peakBetween.price;

  // Double bottom confirmed: current price back near neckline or just broke above
  const nearNeckline = price >= neckline * 0.97;
  const brokePast = price > neckline;

  return {
    doubleBottom: true,
    neckline,
    bottomPrice: (last.price + prev.price) / 2,
    brokePast,
    nearNeckline,
    pattern: brokePast ? "Double Bottom (Confirmed)" : nearNeckline ? "Double Bottom (Near Breakout)" : "Double Bottom (Forming)"
  };
}

// â”€â”€â”€ SMC: LIQUIDITY ZONES (equal highs/lows) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Equal highs = sell-side liquidity above (smart money targets)
// Equal lows = buy-side liquidity below (smart money may sweep before up-move)
function detectLiquidityZones(highs, lows, closes) {
  if (closes.length < 15) return { equalLows: null, equalHighs: null, liquiditySweep: false };
  const price = closes[closes.length - 1];
  const n = closes.length;

  // Check last 30 bars for equal highs/lows (within 0.3%)
  const recentHighs = highs.slice(-30);
  const recentLows = lows.slice(-30);

  let equalHighsPrice = null, equalLowsPrice = null;
  for (let i = 0; i < recentHighs.length - 1; i++) {
    for (let j = i + 3; j < recentHighs.length; j++) {
      if (Math.abs(recentHighs[i] - recentHighs[j]) / recentHighs[i] < 0.003) {
        equalHighsPrice = (recentHighs[i] + recentHighs[j]) / 2;
        break;
      }
    }
    if (equalHighsPrice) break;
  }
  for (let i = 0; i < recentLows.length - 1; i++) {
    for (let j = i + 3; j < recentLows.length; j++) {
      if (Math.abs(recentLows[i] - recentLows[j]) / recentLows[i] < 0.003) {
        equalLowsPrice = (recentLows[i] + recentLows[j]) / 2;
        break;
      }
    }
    if (equalLowsPrice) break;
  }

  // Liquidity sweep: price briefly dipped below equal lows then recovered (stop hunt)
  const prevLow = Math.min(...lows.slice(-5, -1));
  const liquiditySweep = equalLowsPrice && prevLow < equalLowsPrice * 0.998 && price > equalLowsPrice;

  return { equalLows: equalLowsPrice, equalHighs: equalHighsPrice, liquiditySweep };
}

// â”€â”€â”€ SMC: REFINED S/R ZONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcSupportResistance(highs, lows, closes) {
  if (!closes || closes.length < 10) return { support: 0, resistance: 0, nearSupport: false, nearResistance: false, srZones: [] };
  const price = closes[closes.length - 1];
  const { pivotHighs, pivotLows } = findPivots(highs, lows, 3);

  // Build S/R zones by clustering pivot points within 1% of each other
  const allPivots = [
    ...pivotHighs.map(p => ({ price: p.price, type: 'R' })),
    ...pivotLows.map(p => ({ price: p.price, type: 'S' })),
  ].sort((a, b) => a.price - b.price);

  const zones = [];
  for (const pv of allPivots) {
    const existing = zones.find(z => Math.abs(z.price - pv.price) / z.price < 0.012);
    if (existing) { existing.touches++; existing.price = (existing.price + pv.price) / 2; }
    else zones.push({ price: pv.price, type: pv.type, touches: 1 });
  }
  // Sort by touch count (most tested = strongest)
  const strongZones = zones.filter(z => z.touches >= 1).sort((a, b) => b.touches - a.touches);

  // Nearest support below price, nearest resistance above price
  const supportZones = strongZones.filter(z => z.price < price * 0.999).sort((a, b) => b.price - a.price);
  const resistanceZones = strongZones.filter(z => z.price > price * 1.001).sort((a, b) => a.price - b.price);
  const support = supportZones[0]?.price || Math.min(...lows.slice(-20));
  const resistance = resistanceZones[0]?.price || Math.max(...highs.slice(-20));

  const range = resistance - support;
  const pct = range > 0 ? (price - support) / range : 0.5;
  const nearSupport = pct < 0.28;
  const nearResistance = pct > 0.80;

  return {
    support, resistance, pct, nearSupport, nearResistance,
    srZones: strongZones.slice(0, 6),
    supportZones: supportZones.slice(0, 3),
    resistanceZones: resistanceZones.slice(0, 3),
  };
}

function isOverextended(closes, ema20) {
  if (!ema20 || !closes.length) return false;
  return closes[closes.length - 1] > ema20 * 1.08;
}

// â”€â”€â”€ MAIN SCORING ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function scoreOpportunity({ closes, highs, lows, opens, volume, avgVolume }) {
  const price = closes[closes.length - 1];
  const klines = closes.map((c, i) => ({ o: opens[i], h: highs[i], l: lows[i], c }));

  const rsi = calcRSI(closes);
  const ema20 = calcEMA(closes, 20);
  const ema50 = calcEMA(closes, 50);
  const macd = calcMACD(closes);
  const bb = calcBollingerBands(closes);
  const candle = detectCandlePattern(klines);
  const div = detectRSIDivergence(closes);
  const sr = calcSupportResistance(highs, lows, closes);
  const ob = detectOrderBlocks(opens, highs, lows, closes);
  const bos = detectBOS(highs, lows, closes);
  const db = detectDoubleBottom(highs, lows, closes);
  const liq = detectLiquidityZones(highs, lows, closes);
  const volSpike = avgVolume > 0 ? volume / avgVolume : 1;
  const overextended = isOverextended(closes, ema20);

  const emaTrendBull = ema20 && ema50 && ema20 > ema50;
  const priceAboveEma20 = ema20 && price > ema20;

  const factors = {};

  // 1. RSI
  if (rsi < 30)        factors.rsi = { score: 18, label: `RSI ${rsi.toFixed(0)} â€” Oversold`, good: true };
  else if (rsi < 40)   factors.rsi = { score: 22, label: `RSI ${rsi.toFixed(0)} â€” Recovery zone`, good: true };
  else if (rsi < 50)   factors.rsi = { score: 15, label: `RSI ${rsi.toFixed(0)} â€” Neutral`, good: true };
  else if (rsi < 60)   factors.rsi = { score: 8,  label: `RSI ${rsi.toFixed(0)} â€” Elevated`, good: false };
  else if (rsi < 70)   factors.rsi = { score: 3,  label: `RSI ${rsi.toFixed(0)} â€” High`, good: false };
  else                 factors.rsi = { score: -5, label: `RSI ${rsi.toFixed(0)} â€” Overbought`, good: false };

  // 2. MACD
  if (macd.crossover)        factors.macd = { score: 20, label: "MACD Bullish Crossover âœ¦", good: true };
  else if (macd.recentCross) factors.macd = { score: 15, label: "MACD Recent Cross", good: true };
  else if (macd.bullish)     factors.macd = { score: 8,  label: "MACD Bullish", good: true };
  else if (macd.hist > 0)    factors.macd = { score: 4,  label: "MACD Hist Positive", good: true };
  else                       factors.macd = { score: -3, label: "MACD Bearish", good: false };

  // 3. Volume spike
  if (volSpike > 3.0)      factors.volume = { score: 20, label: `Vol Ã—${volSpike.toFixed(1)} â€” Huge spike`, good: true };
  else if (volSpike > 2.0) factors.volume = { score: 15, label: `Vol Ã—${volSpike.toFixed(1)} â€” Strong spike`, good: true };
  else if (volSpike > 1.4) factors.volume = { score: 9,  label: `Vol Ã—${volSpike.toFixed(1)} â€” Elevated`, good: true };
  else if (volSpike > 0.8) factors.volume = { score: 4,  label: `Vol Ã—${volSpike.toFixed(1)} â€” Normal`, good: false };
  else                     factors.volume = { score: 0,  label: `Vol Ã—${volSpike.toFixed(1)} â€” Low`, good: false };

  // 4. Candle pattern
  if (candle.strength >= 3)       factors.candle = { score: 18, label: `${candle.pattern} âœ¦`, good: true };
  else if (candle.strength === 2)  factors.candle = { score: 12, label: candle.pattern, good: true };
  else if (candle.strength === 1)  factors.candle = { score: 6,  label: candle.pattern, good: true };
  else if (candle.strength === 0)  factors.candle = { score: 2,  label: candle.pattern, good: false };
  else                             factors.candle = { score: -5, label: `${candle.pattern} âš `, good: false };

  // 5. Bollinger Bands
  if (bb.pct < 0.1)       factors.bb = { score: 14, label: "At Lower BB â€” Mean reversion setup", good: true };
  else if (bb.pct < 0.25) factors.bb = { score: 10, label: "Near Lower BB", good: true };
  else if (bb.pct < 0.5)  factors.bb = { score: 5,  label: "Mid-BB range", good: true };
  else if (bb.pct < 0.75) factors.bb = { score: 1,  label: "Upper BB half", good: false };
  else                    factors.bb = { score: -4, label: "Near Upper BB â€” Risky entry", good: false };

  // 6. S/R zone position
  if (sr.nearSupport)         factors.sr = { score: 14, label: "At Key S/R Support Zone âœ¦", good: true };
  else if (sr.pct < 0.45)     factors.sr = { score: 7,  label: "Below price midrange", good: true };
  else if (sr.nearResistance) factors.sr = { score: -8, label: "At Resistance Zone â€” Don't buy!", good: false };
  else                        factors.sr = { score: 2,  label: "Mid price range", good: false };

  // 7. EMA trend
  if (emaTrendBull && priceAboveEma20)         factors.trend = { score: 10, label: "Uptrend â€” EMA20 > EMA50", good: true };
  else if (emaTrendBull)                       factors.trend = { score: 6,  label: "Trend bullish, price dipping", good: true };
  else if (!emaTrendBull && !priceAboveEma20)  factors.trend = { score: -5, label: "Downtrend â€” counter-trend risk", good: false };
  else                                         factors.trend = { score: 2,  label: "Mixed trend", good: false };

  // 8. RSI Divergence
  if (div.bullishDiv)      factors.divergence = { score: 12, label: "Bullish RSI Divergence âœ¦ Early signal!", good: true };
  else if (div.bearishDiv) factors.divergence = { score: -6, label: "Bearish RSI Divergence âš ", good: false };
  else                     factors.divergence = { score: 0,  label: "No RSI divergence", good: false };

  // â”€â”€ SMC FACTORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 9. Order Block
  if (ob.atBullishOB) {
    const s = ob.bullishOB?.strength || 1;
    factors.orderBlock = { score: s >= 3 ? 22 : s === 2 ? 16 : 10, label: `Bullish Order Block âœ¦ (demand zone ${s === 3 ? "strong" : "valid"})`, good: true };
  } else if (ob.atBearishOB) {
    factors.orderBlock = { score: -12, label: "Bearish Order Block âš  (supply zone overhead)", good: false };
  } else {
    factors.orderBlock = { score: 0, label: "No active Order Block", good: false };
  }

  // 10. Break of Structure
  if (bos.bullishBOS) {
    factors.bos = { score: 18, label: `BOS â€” Bullish Break of Structure âœ¦ (broke $${bos.bosLevel?.toFixed(4)})`, good: true };
  } else if (bos.choch) {
    factors.bos = { score: 14, label: "CHoCH â€” Change of Character (bearishâ†’bullish flip) âœ¦", good: true };
  } else if (bos.bearishBOS) {
    factors.bos = { score: -10, label: "BOS â€” Bearish structure break âš ", good: false };
  } else {
    factors.bos = { score: 0, label: "No structure break detected", good: false };
  }

  // 11. Double Bottom
  if (db.doubleBottom && db.brokePast) {
    factors.doubleBottom = { score: 16, label: `Double Bottom Confirmed âœ¦ (neckline broken)`, good: true };
  } else if (db.doubleBottom && db.nearNeckline) {
    factors.doubleBottom = { score: 10, label: `Double Bottom Near Breakout âœ¦`, good: true };
  } else if (db.doubleBottom) {
    factors.doubleBottom = { score: 5, label: "Double Bottom Forming", good: true };
  } else {
    factors.doubleBottom = { score: 0, label: "No double bottom", good: false };
  }

  // 12. Liquidity sweep (smart money swept lows then reversed)
  if (liq.liquiditySweep) {
    factors.liquidity = { score: 14, label: "Liquidity Sweep âœ¦ â€” Stop hunt complete, reversal likely", good: true };
  } else if (liq.equalLows && price < liq.equalLows * 1.01) {
    factors.liquidity = { score: 4, label: `Equal Lows at $${liq.equalLows?.toFixed(4)} â€” sweep pending`, good: false };
  } else if (liq.equalHighs && price > liq.equalHighs * 0.99) {
    factors.liquidity = { score: -4, label: "Equal Highs above â€” sell-side liquidity target", good: false };
  } else {
    factors.liquidity = { score: 0, label: "No liquidity zone nearby", good: false };
  }

  // â”€â”€ Hard penalties â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (overextended) {
    factors.overextended = { score: -25, label: "âš  Overextended â€” price >8% above EMA20", good: false };
  }
  if (sr.nearResistance && rsi > 65) {
    factors.topCandle = { score: -15, label: "âš  Possible top â€” RSI high + at resistance zone", good: false };
  }

  const rawScore = Object.values(factors).reduce((s, f) => s + f.score, 0);
  const score = Math.max(0, Math.min(100, Math.round(rawScore + 30)));

  let signal;
  if (score >= 80)      signal = "PRIME";
  else if (score >= 63) signal = "STRONG";
  else if (score >= 45) signal = "WATCH";
  else                  signal = "AVOID";

  // Smart target/stop using OB + S/R zones
  const stopLoss = ob.bullishOB ? ob.bullishOB.low * 0.992 : (sr.support * 0.985 || price * 0.93);
  const target = bos.bosLevel ? price + (price - stopLoss) * 2.5 : (sr.resistance * 0.995 || price * 1.18);
  const rrRatio = stopLoss < price ? ((target - price) / (price - stopLoss)).toFixed(1) : "â€”";

  return {
    rsi, ema20, ema50, macd, bb, candle, div, sr, ob, bos, db, liq,
    volSpike, overextended, emaTrendBull, priceAboveEma20,
    factors, score, signal, target, stopLoss, rrRatio,
    support: sr.support, resistance: sr.resistance,
  };
}

// â”€â”€â”€ SIMULATED FALLBACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SIM_COINS=[
  {symbol:"BTC",price:67500,vol:2.8e9},{symbol:"ETH",price:3480,vol:1.4e9},
  {symbol:"BNB",price:598,vol:480e6},{symbol:"SOL",price:172,vol:640e6},
  {symbol:"XRP",price:0.54,vol:320e6},{symbol:"DOGE",price:0.162,vol:280e6},
  {symbol:"ADA",price:0.457,vol:220e6},{symbol:"AVAX",price:38.2,vol:310e6},
  {symbol:"LINK",price:14.8,vol:190e6},{symbol:"DOT",price:7.4,vol:155e6},
  {symbol:"UNI",price:8.9,vol:170e6},{symbol:"NEAR",price:7.1,vol:210e6},
  {symbol:"LTC",price:84,vol:440e6},{symbol:"MATIC",price:0.72,vol:280e6},
  {symbol:"APT",price:10.4,vol:195e6},{symbol:"ARB",price:1.12,vol:240e6},
  {symbol:"OP",price:2.4,vol:190e6},{symbol:"SUI",price:1.28,vol:290e6},
  {symbol:"INJ",price:27.4,vol:210e6},{symbol:"ATOM",price:8.8,vol:160e6},
  {symbol:"FET",price:2.31,vol:220e6},{symbol:"AAVE",price:98,vol:110e6},
  {symbol:"RNDR",price:8.4,vol:120e6},{symbol:"TIA",price:8.1,vol:130e6},
  {symbol:"RUNE",price:5.4,vol:98e6},{symbol:"STX",price:1.96,vol:120e6},
  {symbol:"IMX",price:2.14,vol:90e6},{symbol:"WLD",price:4.8,vol:140e6},
  {symbol:"BONK",price:0.0000298,vol:180e6},{symbol:"KAS",price:0.128,vol:62e6},
];

function makeSim(coin) {
  const n = 50;
  let p = coin.price;
  const trend = Math.random() > 0.5 ? 1 : -1;
  const closes=[],opens=[],highs=[],lows=[];
  for (let i=0;i<n;i++) {
    const o=p; p*=(1+(Math.random()-0.48)*0.025+trend*0.003);
    const h=Math.max(o,p)*(1+Math.random()*0.01);
    const l=Math.min(o,p)*(1-Math.random()*0.01);
    opens.push(o);closes.push(p);highs.push(h);lows.push(l);
  }
  const avgVol = coin.vol * (0.8+Math.random()*0.4);
  const volume = avgVol * (0.7+Math.random()*2.5);
  const change24h=(closes[n-1]-closes[n-2])/closes[n-2]*100;
  const change7d=(closes[n-1]-closes[Math.max(0,n-43)])/closes[Math.max(0,n-43)]*100;
  const analysis=scoreOpportunity({closes,highs,lows,opens,volume,avgVolume:avgVol});
  return {
    id:coin.symbol,symbol:coin.symbol,name:coin.symbol,
    price:closes[n-1],change24h,change7d,volume,
    closes,opens,highs,lows,...analysis,dataSource:"simulated"
  };
}

// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmtVol(n){if(n>=1e9)return"$"+(n/1e9).toFixed(2)+"B";if(n>=1e6)return"$"+(n/1e6).toFixed(1)+"M";return"$"+n.toFixed(0);}
function fmtPrice(n,sym){if(!n)return"â€”";if(sym==="BTC"||n>=10000)return"$"+Math.round(n).toLocaleString();if(n>=100)return"$"+n.toFixed(1);if(n>=1)return"$"+n.toFixed(2);if(n>=0.01)return"$"+n.toFixed(4);return"$"+n.toFixed(8);}
function pct(n){return(n>=0?"+":"")+n.toFixed(2)+"%";}

// â”€â”€â”€ UI COMPONENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ScoreRing({score}){
  const c=score>=80?"#00ff88":score>=63?"#22c55e":score>=45?"#eab308":"#ef4444";
  const r=16,circ=2*Math.PI*r,dash=circ*(score/100);
  return(
    <svg width="42" height="42" style={{flexShrink:0}}>
      <circle cx="21" cy="21" r={r} fill="none" stroke="#111820" strokeWidth="3"/>
      <circle cx="21" cy="21" r={r} fill="none" stroke={c} strokeWidth="3"
        strokeDasharray={`${dash} ${circ-dash}`} strokeDashoffset={circ/4}
        strokeLinecap="round" style={{filter:`drop-shadow(0 0 4px ${c}88)`}}/>
      <text x="21" y="25" textAnchor="middle" fill={c} fontSize="10" fontFamily="'IBM Plex Mono',monospace" fontWeight="700">{score}</text>
    </svg>
  );
}

function MiniBar({label,value,max,color,danger}){
  const pctFill=Math.max(0,Math.min(100,(value/max)*100));
  return(
    <div style={{marginBottom:5}}>
      <div style={{display:"flex",justifyContent:"space-between",fontSize:9,color:"#3d5070",marginBottom:2}}>
        <span>{label}</span><span style={{color}}>{typeof value==="number"?value.toFixed(1):value}</span>
      </div>
      <div style={{height:3,background:"#111820",borderRadius:2}}>
        <div style={{height:3,width:`${pctFill}%`,background:danger&&pctFill>75?"#ef4444":color,borderRadius:2,transition:"width 0.6s ease"}}/>
      </div>
    </div>
  );
}

function Tag({label,good}){
  const c=good?"#22c55e":"#ef4444";
  return<span style={{background:c+"15",border:`1px solid ${c}40`,color:c,fontSize:9,padding:"1px 6px",borderRadius:3,fontFamily:"'IBM Plex Mono',monospace",whiteSpace:"nowrap"}}>{label}</span>;
}

function StatBox({label,value,color="#c8d4e8",sub}){
  return(
    <div style={{background:"#0b1018",border:"1px solid #1a2535",borderRadius:7,padding:"9px 11px"}}>
      <div style={{fontSize:10,color:"#6a8aaa",textTransform:"uppercase",letterSpacing:1,marginBottom:3}}>{label}</div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:13,color,fontWeight:700}}>{value}</div>
      {sub&&<div style={{fontSize:10,color:"#4a6a8a",marginTop:2}}>{sub}</div>}
    </div>
  );
}

function Section({title,children}){
  return(
    <div style={{marginTop:14}}>
      <div style={{fontSize:10,letterSpacing:2,color:"#6a8aaa",textTransform:"uppercase",fontFamily:"'IBM Plex Mono',monospace",marginBottom:8,display:"flex",alignItems:"center",gap:8,fontWeight:700}}>
        <span>{title}</span><div style={{flex:1,height:1,background:"#131c2e"}}/>
      </div>
      {children}
    </div>
  );
}

function FactorRow({label,score,good}){
  const c=good?"#4ade80":"#f87171";
  return(
    <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"6px 0",borderBottom:"1px solid #0d1520"}}>
      <span style={{fontSize:11,color:"#8ab0d0"}}>{label}</span>
      <span style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:11,color:c,fontWeight:700,minWidth:30,textAlign:"right"}}>{score>=0?"+":""}{score}</span>
    </div>
  );
}

function Row({op,onClick,selected}){
  const sc=SC[op.signal];
  const pos=op.change24h>=0;
  const rsiC=op.rsi<40?"#00ff88":op.rsi>65?"#ef4444":"#94a3b8";
  const isPerp=op.market==="PERP";
  // Priority-ordered badges â€” SMC signals first (highest value)
  const badges=[];
  if(op.bos?.bullishBOS)  badges.push({t:"BOSâ†‘",c:"#00ff88"});
  if(op.bos?.choch)       badges.push({t:"CHoCH",c:"#00e5ff"});
  if(op.ob?.atBullishOB)  badges.push({t:"OB",c:"#f59e0b"});
  if(op.db?.doubleBottom&&op.db?.brokePast) badges.push({t:"2BOTâœ“",c:"#00ff88"});
  else if(op.db?.doubleBottom) badges.push({t:"2BOT",c:"#a3e635"});
  if(op.liq?.liquiditySweep) badges.push({t:"LIQâ†‘",c:"#c084fc"});
  if(op.macd?.crossover||op.macd?.recentCross) badges.push({t:"MACDÃ—",c:"#22c55e"});
  if(op.div?.bullishDiv)  badges.push({t:"DIV",c:"#a78bfa"});
  if(isPerp&&op.funding!==null&&op.funding<-0.0005) badges.push({t:"FR-",c:"#00ff88"});
  if(op.ob?.atBearishOB)  badges.push({t:"SUPâš ",c:"#ef4444"});
  if(op.bos?.bearishBOS)  badges.push({t:"BOSâ†“",c:"#ef4444"});
  if(op.overextended)     badges.push({t:"EXTâš ",c:"#ef4444"});
  if(op.sr?.nearResistance) badges.push({t:"RESâš ",c:"#ef4444"});

  return(
    <div onClick={()=>onClick(op)}
      style={{display:"grid",gridTemplateColumns:"90px 78px 62px 46px 52px 1fr 58px 44px",alignItems:"center",
        padding:"8px 14px",borderBottom:"1px solid #0d1520",gap:0,
        background:selected?SC[op.signal].bg+"cc":"transparent",
        borderLeft:`3px solid ${selected?sc.border:"transparent"}`,cursor:"pointer",transition:"background 0.12s"}}
      onMouseEnter={e=>{if(!selected)e.currentTarget.style.background="#0d1526";}}
      onMouseLeave={e=>{if(!selected)e.currentTarget.style.background="transparent";}}
    >
      <div style={{display:"flex",alignItems:"center",gap:5}}>
        <span style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:13,fontWeight:700,color:"#ffffff"}}>{op.symbol}</span>
        <span style={{fontSize:8,padding:"1px 4px",borderRadius:2,fontFamily:"'IBM Plex Mono',monospace",fontWeight:700,
          background:isPerp?"#0e0a20":"#071828",
          border:`1px solid ${isPerp?"#5a4aaa":"#1a3040"}`,
          color:isPerp?"#a78bfa":"#38bdf8"}}>
          {isPerp?"PERP":"SPOT"}
        </span>
      </div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:12,color:"#e2e8f0",textAlign:"right",paddingRight:8}}>{fmtPrice(op.price,op.symbol)}</div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:12,color:pos?"#4ade80":"#f87171",textAlign:"right",paddingRight:8,fontWeight:600}}>{pct(op.change24h)}</div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:12,color:rsiC,textAlign:"right",paddingRight:8,fontWeight:600}}>{op.rsi.toFixed(0)}</div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:11,color:op.volSpike>2?"#00ff88":"#7dd3fc",textAlign:"right",paddingRight:8}}>Ã—{op.volSpike.toFixed(1)}</div>
      <div style={{display:"flex",gap:3,flexWrap:"wrap",overflow:"hidden",maxHeight:20}}>
        {badges.slice(0,3).map(b=>(
          <span key={b.t} style={{background:b.c+"20",border:`1px solid ${b.c}50`,color:b.c,fontSize:9,padding:"0 5px",borderRadius:3,fontFamily:"'IBM Plex Mono',monospace",lineHeight:"18px",fontWeight:700}}>{b.t}</span>
        ))}
      </div>
      <div style={{display:"flex",justifyContent:"center"}}>
        <span style={{background:sc.bg,border:`1px solid ${sc.border}`,color:sc.text,fontSize:9,fontWeight:700,padding:"2px 6px",borderRadius:3,letterSpacing:1,fontFamily:"'IBM Plex Mono',monospace",whiteSpace:"nowrap",boxShadow:selected?`0 0 10px ${sc.glow}`:undefined}}>
          {op.signal}
        </span>
      </div>
      <div style={{textAlign:"right"}}>
        <ScoreRing score={op.score}/>
      </div>
    </div>
  );
}

function TableHeader({sortBy,setSortBy}){
  const cols=[
    ["symbol","COIN","left"],["price","PRICE","right"],["change24h","24H%","right"],
    ["rsi","RSI","right"],["volSpike","VOLÃ—","right"],["signals","SIGNALS","left"],
    ["signal","TIER","center"],["score","SCORE","right"],
  ];
  const sortable=["price","change24h","rsi","volSpike","score"];
  return(
    <div style={{display:"grid",gridTemplateColumns:"90px 78px 62px 46px 52px 1fr 58px 44px",padding:"7px 14px",borderBottom:"1px solid #131c2e",background:"#060a12",position:"sticky",top:0,zIndex:5}}>
      {cols.map(([key,label,align])=>(
        <div key={key} onClick={()=>sortable.includes(key)&&setSortBy(key)}
          style={{fontSize:10,letterSpacing:1.5,color:sortBy===key?"#38bdf8":"#6a8aaa",textTransform:"uppercase",fontFamily:"'IBM Plex Mono',monospace",textAlign:align,cursor:sortable.includes(key)?"pointer":"default",paddingRight:align==="right"?8:0,userSelect:"none",fontWeight:sortBy===key?700:400}}>
          {label}{sortBy===key?" â–¼":""}
        </div>
      ))}
    </div>
  );
}

function TradingViewChart({symbol}){
  const ref=useRef(null);
  useEffect(()=>{
    if(!ref.current||!symbol) return;
    ref.current.innerHTML="";
    const s=document.createElement("script");
    s.src="https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js";
    s.async=true;
    s.innerHTML=JSON.stringify({
      autosize:true,symbol:`BINANCE:${symbol}USDT`,interval:"240",
      timezone:"Etc/UTC",theme:"dark",style:"1",locale:"en",
      backgroundColor:"#050810",gridColor:"#0d1220",
      hide_top_toolbar:false,save_image:false,
      studies:["RSI@tv-basicstudies","MACD@tv-basicstudies","BB@tv-basicstudies"],
      support_host:"https://www.tradingview.com"
    });
    ref.current.appendChild(s);
  },[symbol]);
  return(
    <div style={{width:"100%",height:310,borderRadius:8,overflow:"hidden",border:"1px solid #0d1220"}}>
      <div ref={ref} style={{width:"100%",height:"100%"}}><div style={{width:"100%",height:"100%"}}/></div>
    </div>
  );
}


function DetailPanel({op,onAlert}){
  if(!op) return(
    <div style={{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",height:"100%",gap:10,padding:20}}>
      <div style={{fontSize:40,opacity:0.12}}>â—ˆ</div>
      <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:12,color:"#6a8aaa",textAlign:"center",lineHeight:1.8}}>
        Select a coin to view<br/>full signal analysis
      </div>
    </div>
  );
  const sc=SC[op.signal];
  const pos=op.change24h>=0;
  const factors=op.factors||{};
  const factorList=Object.entries(factors);
  const totalRaw=factorList.reduce((s,[,f])=>s+f.score,0);

  return(
    <div style={{padding:"14px 16px",overflowY:"auto",height:"100%",animation:"fadeIn 0.2s ease"}}>
      {/* Header */}
      <div style={{display:"flex",justifyContent:"space-between",alignItems:"flex-start",marginBottom:12}}>
        <div>
          <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:18,fontWeight:700,color:"#ffffff",display:"flex",alignItems:"center",gap:8}}>
            {op.symbol}/USDT
            {op.dataSource==="live"&&<span style={{fontSize:9,background:"#071a0f",border:"1px solid #00ff8840",color:"#00ff88",padding:"2px 6px",borderRadius:3}}>LIVE</span>}
          </div>
          <div style={{fontSize:11,color:"#8ab0d0",marginTop:3}}>Swing Trade Signal Analysis Â· 4H</div>
        </div>
        <div style={{textAlign:"right"}}>
          <div style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:18,color:"#ffffff",fontWeight:700}}>{fmtPrice(op.price,op.symbol)}</div>
          <div style={{fontSize:11,color:pos?"#4ade80":"#f87171",fontFamily:"'IBM Plex Mono',monospace",fontWeight:600}}>{pct(op.change24h)} 24h Â· {pct(op.change7d||0)} 7d</div>
        </div>
      </div>

      {/* Signal box */}
      <div style={{background:sc.bg,border:`1px solid ${sc.border}`,borderRadius:8,padding:"10px 14px",display:"flex",justifyContent:"space-between",alignItems:"center",boxShadow:`0 0 20px ${sc.glow}`,marginBottom:4}}>
        <div>
          <div style={{color:sc.text,fontFamily:"'IBM Plex Mono',monospace",fontSize:16,fontWeight:700}}>{op.signal}</div>
          <div style={{fontSize:9,color:sc.text+"99",marginTop:1}}>{op.score>=80?"High probability setup":op.score>=63?"Good setup â€” confirm on chart":op.score>=45?"Wait for confirmation":"Low probability â€” pass"}</div>
        </div>
        <div style={{display:"flex",alignItems:"center",gap:10}}>
          <ScoreRing score={op.score}/>
          <button onClick={()=>onAlert(op)} style={{background:"#000000aa",border:`1px solid ${sc.border}50`,color:sc.text,padding:"5px 10px",borderRadius:4,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:9,letterSpacing:1}}>ğŸ”” ALERT</button>
        </div>
      </div>

      {/* â”€â”€ SMC + INDICATOR ALERT BANNERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      {op.bos?.bullishBOS&&<div style={{background:"#02180a",border:"1px solid #00ff8860",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ”¼</span>
        <span style={{fontSize:11,color:"#00ff88",lineHeight:1.6}}><strong>BREAK OF STRUCTURE (BOS)</strong> â€” Price closed above swing high at {fmtPrice(op.bos.bosLevel,op.symbol)}. Bullish market structure confirmed. High-conviction entry signal â€” smart money is accumulating.</span>
      </div>}
      {op.bos?.choch&&!op.bos?.bullishBOS&&<div style={{background:"#01141a",border:"1px solid #00e5ff60",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ”„</span>
        <span style={{fontSize:11,color:"#00e5ff",lineHeight:1.6}}><strong>CHANGE OF CHARACTER (CHoCH)</strong> â€” Market structure flipped from bearish to bullish. This is the earliest SMC signal before a full BOS forms. Watch for confirmation.</span>
      </div>}
      {op.ob?.atBullishOB&&<div style={{background:"#150f00",border:"1px solid #f59e0b60",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ“¦</span>
        <span style={{fontSize:11,color:"#fbbf24",lineHeight:1.6}}><strong>BULLISH ORDER BLOCK</strong> â€” Price sitting inside institutional demand zone {fmtPrice(op.ob.bullishOB?.low,op.symbol)}â€“{fmtPrice(op.ob.bullishOB?.high,op.symbol)}. This is where big players placed their buy orders before the last up-move. {op.ob.bullishOB?.strength===3?"Strong OB â€” high-probability long entry.":"Valid OB â€” wait for a bullish confirmation candle."}</span>
      </div>}
      {op.db?.doubleBottom&&op.db?.brokePast&&<div style={{background:"#02180a",border:"1px solid #4ade8060",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>â“Œ</span>
        <span style={{fontSize:11,color:"#4ade80",lineHeight:1.6}}><strong>DOUBLE BOTTOM â€” CONFIRMED</strong> â€” Neckline at {fmtPrice(op.db.neckline,op.symbol)} broken. Classic W-pattern reversal complete. Measured move target: {fmtPrice(op.db.neckline+(op.db.neckline-op.db.bottomPrice),op.symbol)}.</span>
      </div>}
      {op.db?.doubleBottom&&!op.db?.brokePast&&op.db?.nearNeckline&&<div style={{background:"#0a1200",border:"1px solid #a3e63560",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>â“Œ</span>
        <span style={{fontSize:11,color:"#a3e635",lineHeight:1.6}}><strong>DOUBLE BOTTOM â€” NEAR BREAKOUT</strong> â€” Two equal lows formed at {fmtPrice(op.db.bottomPrice,op.symbol)}. Neckline resistance at {fmtPrice(op.db.neckline,op.symbol)}. Wait for a 4H candle close above neckline to confirm entry.</span>
      </div>}
      {op.liq?.liquiditySweep&&<div style={{background:"#100018",border:"1px solid #c084fc60",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ¯</span>
        <span style={{fontSize:11,color:"#c084fc",lineHeight:1.6}}><strong>LIQUIDITY SWEEP</strong> â€” Smart money raided stops below equal lows, then reversed. The trap is complete. This is a high-probability SMC reversal setup â€” bulls now in control.</span>
      </div>}
      {op.div?.bullishDiv&&<div style={{background:"#04160b",border:"1px solid #00ff8840",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ“ˆ</span>
        <span style={{fontSize:11,color:"#00ff88",lineHeight:1.6}}><strong>BULLISH RSI DIVERGENCE</strong> â€” Price making lower lows while RSI making higher lows. Momentum is shifting before price moves. One of the most reliable early entry signals.</span>
      </div>}
      {(op.macd?.crossover||op.macd?.recentCross)&&<div style={{background:"#04160b",border:"1px solid #22c55e40",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>âš¡</span>
        <span style={{fontSize:11,color:"#22c55e",lineHeight:1.6}}><strong>MACD BULLISH CROSSOVER</strong> â€” {op.macd?.crossover?"Fresh crossover this bar â€” act quickly.":"Recent cross within last 3 bars."} Momentum confirming bullish bias.</span>
      </div>}
      {op.market==="PERP"&&op.funding!==null&&op.funding<-0.0005&&<div style={{background:"#04160b",border:"1px solid #00ff8840",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ’°</span>
        <span style={{fontSize:11,color:"#00ff88",lineHeight:1.6}}><strong>NEGATIVE FUNDING RATE ({fmtFunding(op.funding)})</strong> â€” Shorts are paying longs. Bearish sentiment is overcrowded â€” a squeeze higher is likely.</span>
      </div>}
      {op.ob?.atBearishOB&&<div style={{background:"#1a0800",border:"1px solid #ef444450",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ“¦</span>
        <span style={{fontSize:11,color:"#f87171",lineHeight:1.6}}><strong>BEARISH ORDER BLOCK</strong> â€” Price at institutional supply zone. This is where smart money sells. High rejection risk â€” avoid entries here.</span>
      </div>}
      {op.bos?.bearishBOS&&<div style={{background:"#1a0808",border:"1px solid #ef444450",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸ”½</span>
        <span style={{fontSize:11,color:"#f87171",lineHeight:1.6}}><strong>BEARISH BREAK OF STRUCTURE</strong> â€” Price broke below a swing low. Bearish market structure. Counter-trend long trades carry high risk.</span>
      </div>}
      {op.overextended&&<div style={{background:"#1c0808",border:"1px solid #ef444440",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>âš ï¸</span>
        <span style={{fontSize:11,color:"#f87171",lineHeight:1.6}}><strong>OVEREXTENDED</strong> â€” Price is &gt;8% above EMA20. You would be chasing. Wait for a pullback to the nearest Order Block or support zone before entering.</span>
      </div>}
      {op.sr?.nearResistance&&!op.bos?.bullishBOS&&<div style={{background:"#1c0808",border:"1px solid #ef444440",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>ğŸš§</span>
        <span style={{fontSize:11,color:"#f87171",lineHeight:1.6}}><strong>AT RESISTANCE ZONE</strong> â€” Price near the top of its recent range. Wait for a confirmed breakout + retest before entering long.</span>
      </div>}
      {op.market==="PERP"&&op.funding!==null&&op.funding>0.003&&<div style={{background:"#1c0808",border:"1px solid #ef444440",borderRadius:7,padding:"9px 12px",marginBottom:5,display:"flex",alignItems:"flex-start",gap:8}}>
        <span style={{fontSize:16,flexShrink:0}}>âš ï¸</span>
        <span style={{fontSize:11,color:"#f87171",lineHeight:1.6}}><strong>HIGH FUNDING RATE ({fmtFunding(op.funding)})</strong> â€” Longs are crowded. Elevated risk of a long squeeze.</span>
      </div>}

      {/* Chart */}
      <div style={{marginTop:10,marginBottom:10}}>
        <TradingViewChart symbol={op.symbol}/>
      </div>

      {/* Trade levels */}
      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr 1fr 1fr",gap:6,marginBottom:10}}>
        <StatBox label="Entry" value={fmtPrice(op.price,op.symbol)} color="#38bdf8"/>
        <StatBox label="Target" value={fmtPrice(op.target,op.symbol)} color="#00ff88" sub={`+${(((op.target-op.price)/op.price)*100).toFixed(1)}%`}/>
        <StatBox label="Stop" value={fmtPrice(op.stopLoss,op.symbol)} color="#ef4444" sub={`-${(((op.price-op.stopLoss)/op.price)*100).toFixed(1)}%`}/>
        <StatBox label="R/R" value={`${op.rrRatio}:1`} color="#eab308" sub={op.rrRatio>=2?"Good ratio":"Low ratio"}/>
      </div>

      {/* Technical grid */}
      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:6,marginBottom:10}}>
        <StatBox label="RSI (14)" value={op.rsi.toFixed(1)} color={op.rsi<40?"#00ff88":op.rsi>65?"#ef4444":"#94a3b8"} sub={op.rsi<40?"Oversold":op.rsi>65?"Overbought":"Neutral"}/>
        <StatBox label="MACD" value={op.macd?.bullish?"Bullish":"Bearish"} color={op.macd?.bullish?"#22c55e":"#ef4444"} sub={op.macd?.crossover?"Fresh crossover!":op.macd?.recentCross?"Recent cross":""}/>
        <StatBox label="BB Position" value={`${(op.bb?.pct*100||50).toFixed(0)}%`} color={op.bb?.pct<0.25?"#00ff88":op.bb?.pct>0.8?"#ef4444":"#94a3b8"} sub={op.bb?.pct<0.25?"Near lower band":op.bb?.pct>0.75?"Near upper band":"Mid range"}/>
        <StatBox label="Vol Spike" value={`Ã—${op.volSpike.toFixed(2)}`} color={op.volSpike>2?"#00ff88":"#38bdf8"} sub={fmtVol(op.volume)}/>
        <StatBox label="EMA Trend" value={op.emaTrendBull?"Bullish":"Bearish"} color={op.emaTrendBull?"#22c55e":"#ef4444"} sub="EMA20 vs EMA50"/>
        <StatBox label="Candle" value={op.candle?.pattern||"â€”"} color={op.candle?.bullish?"#22c55e":"#ef4444"}/>
      </div>

      {/* â”€â”€ SMC ANALYSIS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      <Section title="Smart Money Analysis (SMC)">
        <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:6,marginBottom:8}}>
          <StatBox
            label="Order Block"
            value={op.ob?.atBullishOB?"Bullish OB âœ¦":op.ob?.atBearishOB?"Bearish OB âš ":"None Active"}
            color={op.ob?.atBullishOB?"#fbbf24":op.ob?.atBearishOB?"#f87171":"#6a8aaa"}
            sub={op.ob?.atBullishOB?`Demand ${fmtPrice(op.ob.bullishOB?.low,op.symbol)}â€“${fmtPrice(op.ob.bullishOB?.high,op.symbol)}`:op.ob?.atBearishOB?"Supply zone overhead":"No institutional zone nearby"}
          />
          <StatBox
            label="Structure (BOS)"
            value={op.bos?.bullishBOS?"Bullish BOS âœ¦":op.bos?.choch?"CHoCH âœ¦":op.bos?.bearishBOS?"Bearish BOS âš ":"Ranging"}
            color={op.bos?.bullishBOS?"#00ff88":op.bos?.choch?"#00e5ff":op.bos?.bearishBOS?"#f87171":"#6a8aaa"}
            sub={op.bos?.bullishBOS?`Broke ${fmtPrice(op.bos.bosLevel,op.symbol)}`:op.bos?.choch?"Structure flipping bullish":op.bos?.bearishBOS?"Structure broken down":"No clear break"}
          />
          <StatBox
            label="Double Bottom"
            value={op.db?.doubleBottom?(op.db?.brokePast?"Confirmed âœ¦":op.db?.nearNeckline?"Near Breakout":"Forming"):"Not Detected"}
            color={op.db?.doubleBottom&&op.db?.brokePast?"#4ade80":op.db?.doubleBottom?"#a3e635":"#6a8aaa"}
            sub={op.db?.doubleBottom?`Neckline ${fmtPrice(op.db.neckline,op.symbol)} Â· Base ${fmtPrice(op.db.bottomPrice,op.symbol)}`:"Watch for W pattern at lows"}
          />
          <StatBox
            label="Liquidity"
            value={op.liq?.liquiditySweep?"Swept âœ¦":op.liq?.equalLows?"Equal Lows":op.liq?.equalHighs?"Equal Highs":"Neutral"}
            color={op.liq?.liquiditySweep?"#c084fc":op.liq?.equalLows?"#fbbf24":op.liq?.equalHighs?"#f87171":"#6a8aaa"}
            sub={op.liq?.liquiditySweep?"Stop hunt done â€” reversal likely":op.liq?.equalLows?`BSL at ${fmtPrice(op.liq.equalLows,op.symbol)} â€” sweep pending`:op.liq?.equalHighs?`SSL at ${fmtPrice(op.liq.equalHighs,op.symbol)}`:"No equal highs/lows"}
          />
        </div>
      </Section>

      {/* â”€â”€ S/R ZONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      <Section title="S/R Zones (Multi-Touch Levels)">
        <div style={{background:"#0b1018",border:"1px solid #1a2535",borderRadius:7,padding:"12px 14px",marginBottom:8}}>
          {/* Range bar */}
          <div style={{display:"flex",justifyContent:"space-between",marginBottom:8}}>
            <span style={{fontSize:11,color:"#4ade80",fontWeight:600}}>Support: {fmtPrice(op.support,op.symbol)}</span>
            <span style={{fontSize:11,color:"#f87171",fontWeight:600}}>Resistance: {fmtPrice(op.resistance,op.symbol)}</span>
          </div>
          <div style={{height:10,background:"#131c2e",borderRadius:5,position:"relative",marginBottom:6}}>
            <div style={{position:"absolute",left:0,right:0,top:0,height:10,borderRadius:5,background:"linear-gradient(to right,#22c55e28,#ef444428)"}}>
              {/* S/R zone markers */}
              {(op.sr?.srZones||[]).map((z,i)=>(
                <div key={i} style={{position:"absolute",left:`${Math.max(0,Math.min(100,((z.price-op.support)/(op.resistance-op.support||1))*100))}%`,top:0,width:2,height:10,
                  background:z.type==="S"?"#4ade80":"#f87171",opacity:0.5+z.touches*0.1,transform:"translateX(-50%)"}}/>
              ))}
              <div style={{position:"absolute",left:`${Math.max(2,Math.min(98,(op.sr?.pct||0.5)*100))}%`,transform:"translateX(-50%)",top:-4,width:18,height:18,borderRadius:"50%",background:"#38bdf8",border:"2px solid #060a12",boxShadow:"0 0 8px #38bdf8"}}/>
            </div>
          </div>
          <div style={{display:"flex",justifyContent:"space-between",fontSize:10,color:"#6a8aaa",marginBottom:10}}>
            <span style={{color:"#4ade80"}}>SUPPORT</span>
            <span style={{color:"#7dd3fc",fontWeight:700}}>PRICE AT {((op.sr?.pct||0.5)*100).toFixed(0)}%</span>
            <span style={{color:"#f87171"}}>RESISTANCE</span>
          </div>
          {/* Zone list */}
          {(op.sr?.srZones||[]).slice(0,5).map((z,i)=>{
            const isNear=Math.abs(z.price-op.price)/op.price<0.015;
            const isBelow=z.price<op.price;
            return(
              <div key={i} style={{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"5px 0",borderBottom:"1px solid #0d1520"}}>
                <div style={{display:"flex",alignItems:"center",gap:6}}>
                  <div style={{width:8,height:8,borderRadius:2,background:isBelow?"#4ade80":"#f87171",opacity:0.7+(z.touches-1)*0.1,flexShrink:0}}/>
                  <span style={{fontSize:11,color:isNear?"#ffffff":"#8ab0d0",fontWeight:isNear?700:400}}>{fmtPrice(z.price,op.symbol)}</span>
                  {isNear&&<span style={{fontSize:9,color:"#38bdf8",fontFamily:"'IBM Plex Mono',monospace",fontWeight:700}}>â—„ PRICE HERE</span>}
                </div>
                <div style={{display:"flex",alignItems:"center",gap:6}}>
                  <span style={{fontSize:9,color:isBelow?"#4ade80":"#f87171",fontFamily:"'IBM Plex Mono',monospace"}}>{isBelow?"SUPPORT":"RESIST."}</span>
                  <span style={{fontSize:9,color:"#4a6080",fontFamily:"'IBM Plex Mono',monospace"}}>{z.touches}Ã— tested</span>
                </div>
              </div>
            );
          })}
        </div>
      </Section>

      {/* Futures Data â€” only shown for PERP */}
      {op.market==="PERP"&&(
        <Section title="Futures Data">
          <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:6,marginBottom:8}}>
            <StatBox
              label="Funding Rate"
              value={fmtFunding(op.funding)}
              color={op.funding===null?"#6a8aaa":op.funding<-0.0005?"#00ff88":op.funding<0?"#4ade80":op.funding>0.003?"#f87171":"#e2e8f0"}
              sub={op.funding===null?"â€”":op.funding<-0.0005?"Shorts paying longs âœ¦":op.funding<0?"Slightly bearish funding":op.funding>0.003?"Longs crowded âš ":"Neutral funding"}
            />
            <StatBox
              label="Open Interest"
              value={fmtOI(op.openInterest)}
              color="#a78bfa"
              sub="USDT notional"
            />
          </div>
          <div style={{background:"#0e0a20",border:"1px solid #2a1a50",borderRadius:7,padding:"9px 11px",fontSize:10,color:"#8a80b0",lineHeight:1.7}}>
            <div style={{color:"#a78bfa",fontWeight:700,marginBottom:4,fontSize:11}}>How to read Futures data:</div>
            <div>â€¢ <span style={{color:"#4ade80"}}>Negative funding</span> = shorts paying longs = bullish bias</div>
            <div>â€¢ <span style={{color:"#f87171"}}>High positive funding</span> = longs crowded = squeeze risk</div>
            <div>â€¢ High OI + rising price = strong trend confirmation</div>
            <div>â€¢ High OI + falling price = many trapped longs</div>
          </div>
        </Section>
      )}

      {/* Score breakdown */}
      <div style={{background:"#0b1018",border:"1px solid #1a2535",borderRadius:7,padding:"10px 12px",marginBottom:10}}>
        <div style={{fontSize:10,color:"#8ab0d0",textTransform:"uppercase",letterSpacing:2,marginBottom:8,fontWeight:700}}>Signal Score Breakdown</div>
        {factorList.map(([key,f])=><FactorRow key={key} label={f.label} score={f.score} good={f.good}/>)}
        <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginTop:8,paddingTop:6,borderTop:"1px solid #131c2e"}}>
          <span style={{fontSize:11,color:"#8ab0d0",fontWeight:600}}>Composite Score</span>
          <span style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:14,color:op.score>=80?"#00ff88":op.score>=63?"#22c55e":op.score>=45?"#eab308":"#ef4444",fontWeight:700}}>{op.score}/100</span>
        </div>
      </div>

      {/* Checklist */}
      <div style={{background:"#0b1018",border:"1px solid #1a2535",borderRadius:7,padding:"10px 12px",marginBottom:14}}>
        <div style={{fontSize:10,color:"#8ab0d0",textTransform:"uppercase",letterSpacing:2,marginBottom:8,fontWeight:700}}>Entry Checklist</div>
        {[
          // SMC checks (highest priority)
          [op.ob?.atBullishOB||op.sr?.nearSupport, "At Order Block or key support zone"],
          [op.bos?.bullishBOS||op.bos?.choch, "Bullish structure (BOS or CHoCH confirmed)"],
          [!op.ob?.atBearishOB&&!op.bos?.bearishBOS, "No bearish OB or structure break above"],
          [op.db?.doubleBottom?(op.db.brokePast||op.db.nearNeckline):true, "No active double-top or bearish pattern"],
          [!op.liq?.equalHighs||(op.liq?.liquiditySweep), "Liquidity cleared (or no equal highs nearby)"],
          // Standard technical checks
          [!op.overextended, "Price not overextended (within 8% of EMA20)"],
          [!op.sr?.nearResistance||op.bos?.bullishBOS, "Not at resistance (or confirmed breakout)"],
          [op.rsi<60, "RSI below 60 (not overbought)"],
          [op.macd?.bullish, "MACD momentum bullish"],
          [op.volume>=5e7, "Volume â‰¥ $50M (sufficient liquidity)"],
          [op.candle?.bullish||op.candle?.strength>=1, "Bullish candle pattern on entry bar"],
          [op.rrRatio>=1.5, "R/R ratio â‰¥ 1.5 (stop below OB low)"],
          ...(op.market==="PERP"&&op.funding!==null?[[op.funding<=0.002,"Funding rate not dangerously elevated"]]:[] ),
        ].map(([pass,label],i)=>(
          <div key={i} style={{display:"flex",alignItems:"center",gap:7,marginBottom:5}}>
            <span style={{fontSize:13,color:pass?"#4ade80":"#f87171",fontWeight:700,flexShrink:0}}>{pass?"âœ“":"âœ—"}</span>
            <span style={{fontSize:11,color:pass?"#94b8c8":"#5a6a7a"}}>{label}</span>
          </div>
        ))}
      </div>
      <div style={{height:8}}/>
    </div>
  );
}

function AlertModal({op,onClose}){
  const [webhook,setWebhook]=useState("");
  const [tgToken,setTgToken]=useState("");
  const [tgChat,setTgChat]=useState("");
  const [tab,setTab]=useState("discord");
  const [status,setStatus]=useState(null);
  const warnings=[];
  if(op?.overextended) warnings.push("âš  OVEREXTENDED â€” wait for pullback to OB");
  if(op?.sr?.nearResistance&&!op?.bos?.bullishBOS) warnings.push("âš  AT RESISTANCE â€” risky entry");
  if(op?.ob?.atBearishOB) warnings.push("âš  BEARISH ORDER BLOCK overhead");
  if(op?.bos?.bearishBOS) warnings.push("âš  BEARISH BOS â€” structure broken down");
  const bullish=[];
  if(op?.bos?.bullishBOS) bullish.push(`âœ¦ BOS â€” Broke ${fmtPrice(op.bos.bosLevel,op.symbol)}`);
  if(op?.bos?.choch) bullish.push("âœ¦ CHoCH â€” Structure flipped bullish");
  if(op?.ob?.atBullishOB) bullish.push(`âœ¦ Bullish OB: ${fmtPrice(op.ob.bullishOB?.low,op.symbol)}â€“${fmtPrice(op.ob.bullishOB?.high,op.symbol)}`);
  if(op?.db?.doubleBottom&&op?.db?.brokePast) bullish.push("âœ¦ Double Bottom Confirmed");
  else if(op?.db?.doubleBottom) bullish.push("âœ¦ Double Bottom Forming");
  if(op?.liq?.liquiditySweep) bullish.push("âœ¦ Liquidity Sweep â€” reversal setup");
  if(op?.div?.bullishDiv) bullish.push("âœ¦ Bullish RSI Divergence");
  if(op?.macd?.crossover) bullish.push("âœ¦ MACD Crossover");
  if(op?.sr?.nearSupport) bullish.push("âœ¦ Near Support Zone");
  const msg=op?`ğŸš¨ SWING SCANNER PRO â€” ${op.signal}\n\n${op.symbol}/USDT [${op.market||"SPOT"}] Â· Score: ${op.score}/100\nPrice: ${fmtPrice(op.price,op.symbol)}\n24h: ${pct(op.change24h)} Â· 7d: ${pct(op.change7d||0)}\nRSI: ${op.rsi.toFixed(1)} Â· MACD: ${op.macd?.bullish?"Bull":"Bear"} Â· Vol: Ã—${op.volSpike.toFixed(1)}${op.market==="PERP"&&op.funding!==null?`\nFunding: ${fmtFunding(op.funding)} Â· OI: ${fmtOI(op.openInterest)}`:""}
Candle: ${op.candle?.pattern}\nEntry: ${fmtPrice(op.price,op.symbol)} Â· Target: ${fmtPrice(op.target,op.symbol)} Â· Stop: ${fmtPrice(op.stopLoss,op.symbol)}\nR/R: ${op.rrRatio}:1\n${bullish.length?"\n"+bullish.join("\n"):""}${warnings.length?"\n"+warnings.join("\n"):""}`:"";
  async function sendDiscord(){if(!webhook){setStatus({err:"Enter webhook"});return;}setStatus({loading:true});try{const r=await fetch(webhook,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({content:msg,username:"SwingScanner Pro"})});setStatus(r.ok?{ok:"Sent âœ“"}:{err:r.statusText});}catch(e){setStatus({err:"CORS â€” test from Discord"});}}
  async function sendTelegram(){if(!tgToken||!tgChat){setStatus({err:"Enter token & ID"});return;}setStatus({loading:true});try{const r=await fetch(`https://api.telegram.org/bot${tgToken}/sendMessage`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({chat_id:tgChat,text:msg})});const d=await r.json();setStatus(d.ok?{ok:"Sent âœ“"}:{err:d.description});}catch(e){setStatus({err:e.message});}}
  return(
    <div style={{position:"fixed",inset:0,background:"#000000dd",zIndex:1000,display:"flex",alignItems:"center",justifyContent:"center",backdropFilter:"blur(5px)"}}>
      <div style={{background:"#080b0e",border:"1px solid #1a2535",borderRadius:14,width:460,maxWidth:"95vw",padding:22}}>
        <div style={{display:"flex",justifyContent:"space-between",marginBottom:14}}>
          <span style={{fontFamily:"'IBM Plex Mono',monospace",color:"#dde4f0",fontSize:13,fontWeight:700}}>ğŸ”” Alert â€” {op?.symbol}</span>
          <button onClick={onClose} style={{background:"none",border:"none",color:"#3d5070",cursor:"pointer",fontSize:16}}>âœ•</button>
        </div>
        <div style={{background:"#040608",border:"1px solid #111820",borderRadius:7,padding:"9px 11px",marginBottom:12,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,color:"#4a7090",whiteSpace:"pre-line",lineHeight:1.6,maxHeight:130,overflowY:"auto"}}>{msg}</div>
        <div style={{display:"flex",gap:5,marginBottom:12}}>
          {["discord","telegram","copy"].map(t=><button key={t} onClick={()=>{setTab(t);setStatus(null);}} style={{background:tab===t?"#0d1a28":"transparent",border:`1px solid ${tab===t?"#38bdf8":"#1a2535"}`,color:tab===t?"#38bdf8":"#3d5070",padding:"4px 11px",borderRadius:4,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:9,textTransform:"uppercase"}}>{t}</button>)}
        </div>
        {tab==="discord"&&<><input value={webhook} onChange={e=>setWebhook(e.target.value)} placeholder="https://discord.com/api/webhooks/â€¦" style={{width:"100%",background:"#040608",border:"1px solid #1a2535",color:"#8ab0d0",padding:"7px 9px",borderRadius:5,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none",marginBottom:8}}/><button onClick={sendDiscord} style={{background:"#071428",border:"1px solid #38bdf8",color:"#38bdf8",padding:"7px 14px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,fontWeight:700}}>SEND</button></>}
        {tab==="telegram"&&<><input value={tgToken} onChange={e=>setTgToken(e.target.value)} placeholder="Bot token" style={{width:"100%",background:"#040608",border:"1px solid #1a2535",color:"#8ab0d0",padding:"7px 9px",borderRadius:5,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none",marginBottom:6}}/><input value={tgChat} onChange={e=>setTgChat(e.target.value)} placeholder="Chat ID" style={{width:"100%",background:"#040608",border:"1px solid #1a2535",color:"#8ab0d0",padding:"7px 9px",borderRadius:5,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none",marginBottom:8}}/><button onClick={sendTelegram} style={{background:"#071428",border:"1px solid #38bdf8",color:"#38bdf8",padding:"7px 14px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,fontWeight:700}}>SEND</button></>}
        {tab==="copy"&&<button onClick={()=>{navigator.clipboard.writeText(msg);setStatus({ok:"Copied âœ“"});}} style={{background:"#071428",border:"1px solid #7c6ef0",color:"#7c6ef0",padding:"7px 14px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,fontWeight:700}}>COPY</button>}
        {status&&<div style={{marginTop:9,padding:"6px 9px",borderRadius:5,background:status.ok?"#0d2218":"#1c0a0a",color:status.ok?"#22c55e":"#ef4444",fontFamily:"'IBM Plex Mono',monospace",fontSize:10}}>{status.loading?"Sendingâ€¦":status.ok||status.err}</div>}
      </div>
    </div>
  );
}

function SettingsModal({config,onSave,onClose}){
  const [autoRefresh,setAutoRefresh]=useState(config.autoRefresh||false);
  const [ivl,setIvl]=useState(config.interval||300);
  return(
    <div style={{position:"fixed",inset:0,background:"#000000dd",zIndex:1000,display:"flex",alignItems:"center",justifyContent:"center",backdropFilter:"blur(5px)"}}>
      <div style={{background:"#080b0e",border:"1px solid #1a2535",borderRadius:14,width:380,maxWidth:"95vw",padding:22}}>
        <div style={{display:"flex",justifyContent:"space-between",marginBottom:18}}>
          <span style={{fontFamily:"'IBM Plex Mono',monospace",color:"#dde4f0",fontSize:13,fontWeight:700}}>âš™ Settings</span>
          <button onClick={onClose} style={{background:"none",border:"none",color:"#3d5070",cursor:"pointer",fontSize:16}}>âœ•</button>
        </div>
        <div style={{padding:"10px 12px",background:"#040810",border:"1px solid #111820",borderRadius:7,fontSize:10,color:"#2d4060",lineHeight:2,marginBottom:16}}>
          <div><span style={{color:"#00ff88"}}>â—</span> Binance Spot API â€” 4H klines Â· free Â· no key</div>
          <div><span style={{color:"#a78bfa"}}>â—</span> Binance Futures â€” funding rates Â· open interest</div>
          <div><span style={{color:"#eab308"}}>â—</span> SIM fallback if both APIs unreachable</div>
          <div><span style={{color:"#38bdf8"}}>â—</span> Min volume: $50M USDT (enforced on both)</div>
        </div>
        <div style={{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:16}}>
          <div><div style={{fontSize:11,color:"#4a6080"}}>Auto-refresh</div><div style={{fontSize:9,color:"#243040"}}>Re-scan on interval</div></div>
          <div onClick={()=>setAutoRefresh(v=>!v)} style={{width:42,height:22,borderRadius:11,background:autoRefresh?"#0d2b1a":"#111820",border:`1px solid ${autoRefresh?"#00ff88":"#1a2535"}`,cursor:"pointer",position:"relative",transition:"all 0.2s"}}>
            <div style={{width:16,height:16,borderRadius:"50%",background:autoRefresh?"#00ff88":"#334155",position:"absolute",top:2,left:autoRefresh?22:2,transition:"left 0.2s"}}/>
          </div>
        </div>
        {autoRefresh&&<div style={{marginBottom:16}}>
          <label style={{fontSize:10,color:"#3d5070",display:"block",marginBottom:4}}>Interval</label>
          <select value={ivl} onChange={e=>setIvl(Number(e.target.value))} style={{background:"#040608",border:"1px solid #1a2535",color:"#8ab0d0",padding:"6px 10px",borderRadius:5,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none"}}>
            {[60,120,300,600,1800].map(v=><option key={v} value={v}>{v<120?"1 min":v<300?"2 min":v<600?"5 min":v<1800?"10 min":"30 min"}</option>)}
          </select>
        </div>}
        <div style={{display:"flex",gap:8}}>
          <button onClick={()=>onSave({autoRefresh,interval:ivl})} style={{background:"#071428",border:"1px solid #00ff88",color:"#00ff88",padding:"7px 16px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,fontWeight:700}}>SAVE</button>
          <button onClick={onClose} style={{background:"none",border:"1px solid #1a2535",color:"#3d5070",padding:"7px 16px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10}}>CANCEL</button>
        </div>
      </div>
    </div>
  );
}

const FBASE="https://fapi.binance.com/fapi/v1";

function fmtFunding(rate){
  if(rate===null||rate===undefined) return"â€”";
  const pct=(rate*100).toFixed(4);
  return(rate>=0?"+":"")+pct+"%";
}
function fmtOI(n){
  if(!n) return"â€”";
  if(n>=1e9) return"$"+(n/1e9).toFixed(2)+"B";
  if(n>=1e6) return"$"+(n/1e6).toFixed(1)+"M";
  return"$"+n.toFixed(0);
}

// â”€â”€â”€ MAIN APP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function App(){
  const [ops,setOps]=useState([]);
  const [selected,setSelected]=useState(null);
  const [filter,setFilter]=useState("ALL");
  const [marketFilter,setMarketFilter]=useState("ALL"); // ALL | SPOT | PERP
  const [sortBy,setSortBy]=useState("score");
  const [scanning,setScanning]=useState(false);
  const [progress,setProgress]=useState(0);
  const [lastScan,setLastScan]=useState(null);
  const [alertOp,setAlertOp]=useState(null);
  const [showSettings,setShowSettings]=useState(false);
  const [config,setConfig]=useState({autoRefresh:false,interval:300});
  const [errors,setErrors]=useState([]);
  const [search,setSearch]=useState("");
  const [minScore,setMinScore]=useState(0);
  const [dataMode,setDataMode]=useState("sim");
  const [minVol,setMinVol]=useState(50);
  const [hideWarnings,setHideWarnings]=useState(false);
  const [scanStatus,setScanStatus]=useState("");
  const autoTimer=useRef(null);

  const scan=useCallback(async()=>{
    setScanning(true);setProgress(0);setSelected(null);
    const errs=[];let liveOk=false;let result=[];

    async function buildFromKlines(sym, price, change24h, volume, klines, extras={}){
      if(!klines||klines.length<20) return null;
      const opens=klines.map(k=>parseFloat(k[1]));
      const highs=klines.map(k=>parseFloat(k[2]));
      const lows=klines.map(k=>parseFloat(k[3]));
      const closes=klines.map(k=>parseFloat(k[4]));
      const vols=klines.map(k=>parseFloat(k[5]));
      const avgVolume=vols.slice(-21,-1).reduce((a,b)=>a+b,0)/20;
      const currVolume=vols[vols.length-1];
      const change7d=closes.length>=42?((closes[closes.length-1]-closes[closes.length-42])/closes[closes.length-42])*100:change24h;
      const analysis=scoreOpportunity({closes,highs,lows,opens,volume:currVolume,avgVolume});
      return{id:sym,symbol:sym,name:sym,price,change24h,change7d,volume,closes,opens,highs,lows,...analysis,dataSource:"live",...extras};
    }

    try{
      const stables=new Set(["USDT","BUSD","USDC","TUSD","DAI","FDUSD","USDP","USDD","EUR","GBP"]);

      // â”€â”€ PHASE 1: Fetch Spot + Futures tickers in parallel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      setScanStatus("Fetching Spot & Futures tickersâ€¦");
      const [spotRes, futRes] = await Promise.allSettled([
        fetch(`${BASE}/ticker/24hr`),
        fetch(`${FBASE}/ticker/24hr`),
      ]);
      setProgress(15);

      // â”€â”€ Spot pairs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let spotPairs=[];
      if(spotRes.status==="fulfilled"&&spotRes.value.ok){
        const all=await spotRes.value.json();
        spotPairs=all
          .filter(t=>t.symbol.endsWith("USDT")&&!stables.has(t.symbol.replace("USDT",""))&&parseFloat(t.quoteVolume)>=5e7)
          .sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume))
          .slice(0,150)
          .map(t=>({symbol:t.symbol,base:t.symbol.replace("USDT",""),price:parseFloat(t.lastPrice),change24h:parseFloat(t.priceChangePercent),volume:parseFloat(t.quoteVolume),market:"SPOT"}));
      } else errs.push("Spot API unavailable");

      // â”€â”€ Futures pairs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let futPairs=[];
      let fundingMap={};
      let oiMap={};
      if(futRes.status==="fulfilled"&&futRes.value.ok){
        const all=await futRes.value.json();
        futPairs=all
          .filter(t=>t.symbol.endsWith("USDT")&&!stables.has(t.symbol.replace("USDT",""))&&parseFloat(t.quoteVolume)>=5e7)
          .sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume))
          .slice(0,150)
          .map(t=>({symbol:t.symbol,base:t.symbol.replace("USDT",""),price:parseFloat(t.lastPrice),change24h:parseFloat(t.priceChangePercent),volume:parseFloat(t.quoteVolume),market:"PERP"}));

        // Fetch funding rates + open interest in parallel (bulk endpoints)
        setScanStatus("Fetching funding rates & open interestâ€¦");
        const [frRes, oiRes] = await Promise.allSettled([
          fetch(`${FBASE}/premiumIndex`),
          fetch(`${FBASE}/openInterest?symbol=`), // will 400, use per-symbol fallback
        ]);

        if(frRes.status==="fulfilled"&&frRes.value.ok){
          const frData=await frRes.value.json();
          frData.forEach(d=>{fundingMap[d.symbol]=parseFloat(d.lastFundingRate);});
        }

        // Fetch open interest per futures symbol in batches
        const futSymbols=futPairs.map(p=>p.symbol);
        const OI_BATCH=15;
        for(let i=0;i<Math.min(futSymbols.length,90);i+=OI_BATCH){
          const batch=futSymbols.slice(i,i+OI_BATCH);
          await Promise.all(batch.map(async sym=>{
            try{
              const r=await fetch(`${FBASE}/openInterest?symbol=${sym}`);
              if(r.ok){const d=await r.json();oiMap[sym]=parseFloat(d.openInterest)*parseFloat(d.openInterest>0?futPairs.find(p=>p.symbol===sym)?.price||1:1);}
            }catch(e){}
          }));
        }
      } else errs.push("Futures API unavailable");

      setProgress(35);
      setScanStatus("Loading 4H klines for Spot & Futuresâ€¦");

      // â”€â”€ PHASE 2: Fetch klines â€” spot from spot API, futures from fapi â”€â”€â”€â”€â”€â”€â”€
      const BATCH=10;
      const spotKMap={};const futKMap={};

      // Spot klines
      for(let i=0;i<spotPairs.length;i+=BATCH){
        const batch=spotPairs.slice(i,i+BATCH);
        await Promise.all(batch.map(async p=>{
          try{const r=await fetch(`${BASE}/klines?symbol=${p.symbol}&interval=4h&limit=100`);if(r.ok){const d=await r.json();spotKMap[p.symbol]=d;}}catch(e){}
        }));
        setProgress(35+Math.round(((i+BATCH)/spotPairs.length)*25));
      }

      // Futures klines
      for(let i=0;i<futPairs.length;i+=BATCH){
        const batch=futPairs.slice(i,i+BATCH);
        await Promise.all(batch.map(async p=>{
          try{const r=await fetch(`${FBASE}/klines?symbol=${p.symbol}&interval=4h&limit=100`);if(r.ok){const d=await r.json();futKMap[p.symbol]=d;}}catch(e){}
        }));
        setProgress(60+Math.round(((i+BATCH)/futPairs.length)*25));
      }

      setProgress(85);
      setScanStatus("Scoring signalsâ€¦");

      // â”€â”€ PHASE 3: Build opportunities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const spotOps=(await Promise.all(spotPairs.map(p=>
        buildFromKlines(p.base,p.price,p.change24h,p.volume,spotKMap[p.symbol],{market:"SPOT"})
      ))).filter(Boolean);

      const futOps=(await Promise.all(futPairs.map(p=>{
        const funding=fundingMap[p.symbol]??null;
        const openInterest=oiMap[p.symbol]||0;
        // Funding score bonus: negative funding = shorts paying longs = bullish
        let fundingBonus=0;
        if(funding!==null){
          if(funding<-0.001) fundingBonus=8;       // Very negative = strong bullish signal
          else if(funding<0) fundingBonus=4;        // Slightly negative
          else if(funding>0.003) fundingBonus=-5;   // Very positive = longs crowded = risky
        }
        return buildFromKlines(p.base,p.price,p.change24h,p.volume,futKMap[p.symbol],{
          market:"PERP", funding, openInterest, fundingBonus
        });
      }))).filter(Boolean);

      // Apply funding bonus to futures score
      futOps.forEach(op=>{
        if(op.fundingBonus){
          op.score=Math.max(0,Math.min(100,op.score+op.fundingBonus));
          if(op.score>=80) op.signal="PRIME";
          else if(op.score>=63) op.signal="STRONG";
          else if(op.score>=45) op.signal="WATCH";
          else op.signal="AVOID";
        }
      });

      // Merge: deduplicate by base symbol â€” if both exist, prefer higher score
      const byBase={};
      [...spotOps,...futOps].forEach(op=>{
        const key=op.symbol;
        if(!byBase[key]||op.score>byBase[key].score) byBase[key]=op;
        else if(byBase[key]&&op.market!==byBase[key].market){
          // Keep both as separate entries with unique IDs
          byBase[key+"-"+op.market]=op;
        }
      });
      result=Object.values(byBase);
      liveOk=spotOps.length>0||futOps.length>0;

    }catch(e){
      errs.push(`Error: ${e.message}`);
      result=SIM_COINS.map(makeSim);
    }

    setProgress(100);setScanStatus("");setOps(result);setLastScan(new Date());setErrors(errs);setDataMode(liveOk?"live":"sim");setScanning(false);
  },[]);

  useEffect(()=>{scan();},[]);
  useEffect(()=>{
    if(autoTimer.current) clearInterval(autoTimer.current);
    if(config.autoRefresh) autoTimer.current=setInterval(scan,config.interval*1000);
    return()=>{if(autoTimer.current) clearInterval(autoTimer.current);};
  },[config,scan]);

  const TIERS=["ALL","PRIME","STRONG","WATCH","AVOID"];
  const filtered=useMemo(()=>ops
    .filter(o=>filter==="ALL"||o.signal===filter)
    .filter(o=>marketFilter==="ALL"||o.market===marketFilter)
    .filter(o=>o.score>=minScore)
    .filter(o=>o.volume>=(minVol*1e6))
    .filter(o=>!hideWarnings||(o.signal!=="AVOID"&&!o.overextended&&!o.sr?.nearResistance))
    .filter(o=>!search||o.symbol.toLowerCase().includes(search.toLowerCase()))
    .sort((a,b)=>{
      if(sortBy==="score") return b.score-a.score;
      if(sortBy==="rsi") return a.rsi-b.rsi;
      if(sortBy==="volSpike") return b.volSpike-a.volSpike;
      if(sortBy==="change24h") return b.change24h-a.change24h;
      if(sortBy==="price") return b.price-a.price;
      return b.score-a.score;
    })
  ,[ops,filter,marketFilter,minScore,minVol,hideWarnings,search,sortBy]);

  const primes=ops.filter(o=>o.signal==="PRIME").length;
  const strongs=ops.filter(o=>o.signal==="STRONG").length;
  const divs=ops.filter(o=>o.div?.bullishDiv).length;
  const crossovers=ops.filter(o=>o.macd?.crossover||o.macd?.recentCross).length;
  const spotCount=ops.filter(o=>o.market==="SPOT").length;
  const perpCount=ops.filter(o=>o.market==="PERP").length;

  return(
    <div style={{height:"100vh",background:"#040608",fontFamily:"'DM Sans',sans-serif",color:"#c8d4e8",display:"flex",flexDirection:"column",overflow:"hidden"}}>

      {/* HEADER */}
      <div style={{borderBottom:"1px solid #131c2e",padding:"10px 16px",display:"flex",justifyContent:"space-between",alignItems:"center",background:"#060a12",flexShrink:0}}>
        <div style={{display:"flex",alignItems:"center",gap:12,flexWrap:"wrap"}}>
          <div style={{display:"flex",alignItems:"center",gap:8}}>
            <div style={{width:8,height:8,borderRadius:"50%",background:"#00ff88",boxShadow:"0 0 10px #00ff88",animation:"pulse 2s infinite"}}/>
            <span style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:14,fontWeight:700,letterSpacing:2,color:"#ffffff"}}>SWING SCANNER PRO</span>
            <span style={{fontSize:10,background:"#0e1828",border:"1px solid #1e3040",color:"#6a8aaa",padding:"2px 7px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace"}}>4H Â· BINANCE Â· $50M+</span>
            {dataMode==="live"
              ?<span style={{fontSize:10,background:"#071a0f",border:"1px solid #00ff8870",color:"#00ff88",padding:"2px 8px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace",fontWeight:700}}>â— LIVE</span>
              :<span style={{fontSize:10,background:"#161200",border:"1px solid #eab30870",color:"#eab308",padding:"2px 8px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace",fontWeight:700}}>â— SIM</span>}
          </div>
          <div style={{height:16,width:1,background:"#1a2535"}}/>
          <span style={{fontSize:11,color:"#00ff88",fontFamily:"'IBM Plex Mono',monospace",fontWeight:700}}>{primes} PRIME</span>
          <span style={{fontSize:11,color:"#22c55e",fontFamily:"'IBM Plex Mono',monospace",fontWeight:700}}>{strongs} STRONG</span>
          <span style={{fontSize:11,color:"#a78bfa",fontFamily:"'IBM Plex Mono',monospace"}}>{divs} DIV</span>
          <span style={{fontSize:11,color:"#38bdf8",fontFamily:"'IBM Plex Mono',monospace"}}>{crossovers} MACDÃ—</span>
          <span style={{fontSize:11,color:"#4a6080",fontFamily:"'IBM Plex Mono',monospace"}}>{ops.length} coins</span>
          <span style={{fontSize:10,color:"#38bdf8",fontFamily:"'IBM Plex Mono',monospace",background:"#071828",border:"1px solid #1a3040",padding:"1px 6px",borderRadius:3}}>SPOT {spotCount}</span>
          <span style={{fontSize:10,color:"#a78bfa",fontFamily:"'IBM Plex Mono',monospace",background:"#0e0a20",border:"1px solid #2a1a50",padding:"1px 6px",borderRadius:3}}>PERP {perpCount}</span>
          {errors.length>0&&<span style={{fontSize:10,color:"#f87171",background:"#1c0808",border:"1px solid #3a1010",padding:"2px 8px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace"}}>âš  {errors[0]}</span>}
        </div>
        <div style={{display:"flex",alignItems:"center",gap:8}}>
          {lastScan&&<span style={{fontSize:10,color:"#4a6080",fontFamily:"'IBM Plex Mono',monospace"}}>{lastScan.toLocaleTimeString()}</span>}
          {config.autoRefresh&&<span style={{fontSize:10,color:"#22c55e",fontFamily:"'IBM Plex Mono',monospace"}}>AUTO âœ“</span>}
          <button onClick={()=>setShowSettings(true)} style={{background:"#0e1828",border:"1px solid #1e3040",color:"#8ab0d0",padding:"6px 12px",borderRadius:5,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:11}}>âš™ CONFIG</button>
          <button onClick={scan} disabled={scanning} style={{background:scanning?"#040810":"#071f0e",border:`1px solid ${scanning?"#1a2535":"#00ff88"}`,color:scanning?"#3a5040":"#00ff88",padding:"6px 16px",borderRadius:5,cursor:scanning?"not-allowed":"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:11,fontWeight:700,letterSpacing:1}}>
            {scanning?`âŸ³ ${progress}%`:"âŸ³ SCAN"}
          </button>
        </div>
      </div>

      {scanning&&<div style={{height:2,background:"#080d14",flexShrink:0}}><div style={{height:2,background:"#00ff88",width:`${progress}%`,transition:"width 0.3s ease",boxShadow:"0 0 8px #00ff88"}}/></div>}

      {/* FILTER BAR */}
      <div style={{padding:"7px 14px",borderBottom:"1px solid #0d1520",display:"flex",justifyContent:"space-between",alignItems:"center",flexShrink:0,gap:8,flexWrap:"wrap",background:"#050810"}}>
        <div style={{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"}}>
          {/* Signal tier tabs */}
          <div style={{display:"flex",gap:4}}>
            {TIERS.map(t=>{
              const s=t!=="ALL"?SC[t]:null;
              return<button key={t} onClick={()=>setFilter(t)} style={{background:filter===t?(s?s.bg:"#0e1828"):"transparent",border:`1px solid ${filter===t?(s?s.border:"#38bdf8"):"#1a2535"}`,color:filter===t?(s?s.text:"#38bdf8"):"#6a8aaa",padding:"4px 11px",borderRadius:4,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,letterSpacing:1,fontWeight:filter===t?700:400}}>{t}</button>;
            })}
          </div>
          {/* Divider */}
          <div style={{width:1,height:20,background:"#1a2535"}}/>
          {/* Market type tabs */}
          <div style={{display:"flex",gap:3}}>
            {[["ALL","ALL","#6a8aaa"],["SPOT","SPOT","#38bdf8"],["PERP","PERP","#a78bfa"]].map(([val,label,c])=>(
              <button key={val} onClick={()=>setMarketFilter(val)}
                style={{background:marketFilter===val?"#0a1020":"transparent",border:`1px solid ${marketFilter===val?c:"#1a2535"}`,color:marketFilter===val?c:"#6a8aaa",padding:"4px 10px",borderRadius:4,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,letterSpacing:1,fontWeight:marketFilter===val?700:400}}>
                {label}
              </button>
            ))}
          </div>
        </div>
        <div style={{display:"flex",gap:6,alignItems:"center",flexWrap:"wrap"}}>
          <input value={search} onChange={e=>setSearch(e.target.value)} placeholder="âŒ• Search coinâ€¦" style={{background:"#0a0f1a",border:"1px solid #1a2535",color:"#c8d4e8",padding:"5px 9px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none",width:110}}/>
          <select value={minScore} onChange={e=>setMinScore(Number(e.target.value))} style={{background:"#0a0f1a",border:"1px solid #1a2535",color:"#c8d4e8",padding:"5px 7px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none"}}>
            {[0,40,50,60,70,80].map(v=><option key={v} value={v}>{v===0?"Score: All":"Score â‰¥"+v}</option>)}
          </select>
          <select value={minVol} onChange={e=>setMinVol(Number(e.target.value))} style={{background:"#0a0f1a",border:"1px solid #1a2535",color:"#c8d4e8",padding:"5px 7px",borderRadius:4,fontFamily:"'IBM Plex Mono',monospace",fontSize:10,outline:"none"}}>
            {[50,100,200,500].map(v=><option key={v} value={v}>Vol â‰¥${v}M</option>)}
          </select>
          <button onClick={()=>setHideWarnings(v=>!v)} style={{background:hideWarnings?"#1a1000":"#0a0f1a",border:`1px solid ${hideWarnings?"#eab308":"#1a2535"}`,color:hideWarnings?"#eab308":"#6a8aaa",padding:"4px 10px",borderRadius:4,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:10,fontWeight:hideWarnings?700:400}}>
            {hideWarnings?"SAFE MODE âœ“":"SAFE MODE"}
          </button>
          <span style={{fontSize:10,color:"#4a6080",fontFamily:"'IBM Plex Mono',monospace"}}>{filtered.length} results</span>
        </div>
      </div>

      {/* MAIN */}
      <div style={{display:"flex",flex:1,overflow:"hidden"}}>
        <div style={{flex:1,overflowY:"auto",overflowX:"hidden"}}>
          {scanning&&ops.length===0?(
            <div style={{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",height:"100%",gap:10}}>
              <div style={{fontFamily:"'IBM Plex Mono',monospace",color:"#00ff88",fontSize:13,letterSpacing:4,animation:"blink 1s ease-in-out infinite"}}>SCANNING BINANCE</div>
              <div style={{color:"#6a8aaa",fontSize:11,letterSpacing:1,marginTop:4}}>{scanStatus||"Initialisingâ€¦"}</div>
              <div style={{color:"#4a6080",fontSize:10}}>{progress}%</div>
            </div>
          ):(
            <>
              <TableHeader sortBy={sortBy} setSortBy={setSortBy}/>
              {filtered.length===0&&<div style={{color:"#6a8aaa",fontSize:13,textAlign:"center",marginTop:60,fontFamily:"'IBM Plex Mono',monospace"}}>No coins match current filters</div>}
              {filtered.map(op=><Row key={op.id} op={op} onClick={setSelected} selected={selected?.id===op.id}/>)}
            </>
          )}
        </div>
        {selected&&(
          <div style={{width:440,borderLeft:"1px solid #131c2e",overflowY:"auto",background:"#060a12",flexShrink:0,display:"flex",flexDirection:"column"}}>
            {/* Sticky back bar */}
            <div style={{position:"sticky",top:0,zIndex:10,background:"#060a12",borderBottom:"1px solid #131c2e",padding:"10px 14px",display:"flex",alignItems:"center",justifyContent:"space-between",flexShrink:0}}>
              <button
                onClick={()=>setSelected(null)}
                style={{display:"flex",alignItems:"center",gap:7,background:"#0e1828",border:"1px solid #1e3040",color:"#c8d4e8",padding:"7px 14px",borderRadius:6,cursor:"pointer",fontFamily:"'IBM Plex Mono',monospace",fontSize:11,fontWeight:700,letterSpacing:1,transition:"all 0.15s"}}
                onMouseEnter={e=>{e.currentTarget.style.background="#162030";e.currentTarget.style.borderColor="#38bdf8";e.currentTarget.style.color="#38bdf8";}}
                onMouseLeave={e=>{e.currentTarget.style.background="#0e1828";e.currentTarget.style.borderColor="#1e3040";e.currentTarget.style.color="#c8d4e8";}}
              >
                â† BACK TO LIST
              </button>
              <span style={{fontFamily:"'IBM Plex Mono',monospace",fontSize:12,color:"#ffffff",fontWeight:700}}>{selected.symbol}/USDT</span>
            </div>
            <div style={{flex:1,overflowY:"auto"}}>
              <DetailPanel op={selected} onAlert={setAlertOp}/>
            </div>
          </div>
        )}
      </div>

      {alertOp&&<AlertModal op={alertOp} onClose={()=>setAlertOp(null)}/>}
      {showSettings&&<SettingsModal config={config} onSave={c=>{setConfig(c);setShowSettings(false);}} onClose={()=>setShowSettings(false)}/>}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
</script>
</body>
</html>
